// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sectran_admin/ent/account"
	"sectran_admin/ent/department"
	"sectran_admin/ent/device"
	"sectran_admin/ent/labletree"
	"sectran_admin/ent/role"
	"sectran_admin/ent/user"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type AccountPager struct {
	Order  account.OrderOption
	Filter func(*AccountQuery) (*AccountQuery, error)
}

// AccountPaginateOption enables pagination customization.
type AccountPaginateOption func(*AccountPager)

// DefaultAccountOrder is the default ordering of Account.
var DefaultAccountOrder = Desc(account.FieldID)

func newAccountPager(opts []AccountPaginateOption) (*AccountPager, error) {
	pager := &AccountPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultAccountOrder
	}
	return pager, nil
}

func (p *AccountPager) ApplyFilter(query *AccountQuery) (*AccountQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// AccountPageList is Account PageList result.
type AccountPageList struct {
	List        []*Account   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (a *AccountQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...AccountPaginateOption,
) (*AccountPageList, error) {

	pager, err := newAccountPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.ApplyFilter(a); err != nil {
		return nil, err
	}

	ret := &AccountPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := a.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		a = a.Order(pager.Order)
	} else {
		a = a.Order(DefaultAccountOrder)
	}

	a = a.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type DepartmentPager struct {
	Order  department.OrderOption
	Filter func(*DepartmentQuery) (*DepartmentQuery, error)
}

// DepartmentPaginateOption enables pagination customization.
type DepartmentPaginateOption func(*DepartmentPager)

// DefaultDepartmentOrder is the default ordering of Department.
var DefaultDepartmentOrder = Desc(department.FieldID)

func newDepartmentPager(opts []DepartmentPaginateOption) (*DepartmentPager, error) {
	pager := &DepartmentPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDepartmentOrder
	}
	return pager, nil
}

func (p *DepartmentPager) ApplyFilter(query *DepartmentQuery) (*DepartmentQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DepartmentPageList is Department PageList result.
type DepartmentPageList struct {
	List        []*Department `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (d *DepartmentQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...DepartmentPaginateOption,
) (*DepartmentPageList, error) {

	pager, err := newDepartmentPager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.ApplyFilter(d); err != nil {
		return nil, err
	}

	ret := &DepartmentPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := d.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		d = d.Order(pager.Order)
	} else {
		d = d.Order(DefaultDepartmentOrder)
	}

	d = d.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type DevicePager struct {
	Order  device.OrderOption
	Filter func(*DeviceQuery) (*DeviceQuery, error)
}

// DevicePaginateOption enables pagination customization.
type DevicePaginateOption func(*DevicePager)

// DefaultDeviceOrder is the default ordering of Device.
var DefaultDeviceOrder = Desc(device.FieldID)

func newDevicePager(opts []DevicePaginateOption) (*DevicePager, error) {
	pager := &DevicePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDeviceOrder
	}
	return pager, nil
}

func (p *DevicePager) ApplyFilter(query *DeviceQuery) (*DeviceQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DevicePageList is Device PageList result.
type DevicePageList struct {
	List        []*Device    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (d *DeviceQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...DevicePaginateOption,
) (*DevicePageList, error) {

	pager, err := newDevicePager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.ApplyFilter(d); err != nil {
		return nil, err
	}

	ret := &DevicePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := d.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		d = d.Order(pager.Order)
	} else {
		d = d.Order(DefaultDeviceOrder)
	}

	d = d.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type LableTreePager struct {
	Order  labletree.OrderOption
	Filter func(*LableTreeQuery) (*LableTreeQuery, error)
}

// LableTreePaginateOption enables pagination customization.
type LableTreePaginateOption func(*LableTreePager)

// DefaultLableTreeOrder is the default ordering of LableTree.
var DefaultLableTreeOrder = Desc(labletree.FieldID)

func newLableTreePager(opts []LableTreePaginateOption) (*LableTreePager, error) {
	pager := &LableTreePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultLableTreeOrder
	}
	return pager, nil
}

func (p *LableTreePager) ApplyFilter(query *LableTreeQuery) (*LableTreeQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// LableTreePageList is LableTree PageList result.
type LableTreePageList struct {
	List        []*LableTree `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (lt *LableTreeQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...LableTreePaginateOption,
) (*LableTreePageList, error) {

	pager, err := newLableTreePager(opts)
	if err != nil {
		return nil, err
	}

	if lt, err = pager.ApplyFilter(lt); err != nil {
		return nil, err
	}

	ret := &LableTreePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := lt.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		lt = lt.Order(pager.Order)
	} else {
		lt = lt.Order(DefaultLableTreeOrder)
	}

	lt = lt.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := lt.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type RolePager struct {
	Order  role.OrderOption
	Filter func(*RoleQuery) (*RoleQuery, error)
}

// RolePaginateOption enables pagination customization.
type RolePaginateOption func(*RolePager)

// DefaultRoleOrder is the default ordering of Role.
var DefaultRoleOrder = Desc(role.FieldID)

func newRolePager(opts []RolePaginateOption) (*RolePager, error) {
	pager := &RolePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultRoleOrder
	}
	return pager, nil
}

func (p *RolePager) ApplyFilter(query *RoleQuery) (*RoleQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// RolePageList is Role PageList result.
type RolePageList struct {
	List        []*Role      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (r *RoleQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...RolePaginateOption,
) (*RolePageList, error) {

	pager, err := newRolePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.ApplyFilter(r); err != nil {
		return nil, err
	}

	ret := &RolePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := r.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		r = r.Order(pager.Order)
	} else {
		r = r.Order(DefaultRoleOrder)
	}

	r = r.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type UserPager struct {
	Order  user.OrderOption
	Filter func(*UserQuery) (*UserQuery, error)
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*UserPager)

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = Desc(user.FieldID)

func newUserPager(opts []UserPaginateOption) (*UserPager, error) {
	pager := &UserPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultUserOrder
	}
	return pager, nil
}

func (p *UserPager) ApplyFilter(query *UserQuery) (*UserQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// UserPageList is User PageList result.
type UserPageList struct {
	List        []*User      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (u *UserQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...UserPaginateOption,
) (*UserPageList, error) {

	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.ApplyFilter(u); err != nil {
		return nil, err
	}

	ret := &UserPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := u.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		u = u.Order(pager.Order)
	} else {
		u = u.Order(DefaultUserOrder)
	}

	u = u.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
